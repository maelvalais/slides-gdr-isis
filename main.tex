\input{config.tex} % Les usepackage sont dans config.tex
\input{macros.tex} % 



\title{Optimisation de dictionnaires structurés en arbres de convolutions pour la représentation parcimonieuse d'images}
\subtitle{Stage encadré par\\François Malgouyres (IMT), Jean-Yves Tourneret (IRIT-ENSEEIHT) et Herwig Wendt (CNRS-ENSEEIHT)}



\date{Soutenance de stage du 8 septembre 2016}
\author{Maël Valais}
\institute{Université Toulouse III - Paul Sabatier}

\begin{document}

\maketitle


\section{Introduction}
\subsection{La représentation parcimonieuse}


\begin{frame}{La représentation parcimonieuse}
\begin{itemize}
\item Exemple d'application de la représentation parcimonieuse : \alert{débruitage} en utilisant un dictionnaire de DCT sur une image bruitée
	\begin{figure}\centering
	\makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/0-exple-denoise/exple-denoise.pdf}}
	\end{figure}
\item Représentation parcimonieuse permet aussi la \alert{reconnaissance d'images}, la \alert{compression}
\end{itemize}
\end{frame}


\subsection{Dictionnaires}
\begin{frame}{Les dictionnaires}
\begin{itemize}
\item Dictionnaire = opérateur, transformée 
\item Permet de représenter parcimonieusement
\item Deux grands types de dictionnaires : \alert{générique} et \alert{appris}
	\begin{table}[] \centering
	\begin{tabular}{@{}lcc@{}} \toprule
	 & Rapide & Adaptatif \\ \midrule
	DCT (générique) & \cmark & \xmark\\
	K-SVD (appris) & \xmark & \cmark \\ \bottomrule
	\end{tabular}
	\end{table}
\end{itemize}
\end{frame}

\begin{frame}{Problème du coût de Dx}
Problème d'apprentissage de dictionnaire \eqref{eq_dl} pour apprendre un dictionnaire parcimonieux :
\begin{align} 
\underset{\D,\x}{\min}~ & \| \x \|_1 + \lambda \| \alert{\D\x}-\y \|^2_2 \tag{$DL$}\label{eq_dl} \\
\text{s.t.}~ & \| \d_k \| \le \gamma & \forall k = 1,\dots,K \label{eq_dl_finite_norm} \notag
\end{align}
 avec $\y \in \R^N$ l'image sur laquelle on apprend, $\x \in \R^{K}$ le code, $\D$ la matrice $K \times N$.

\begin{alertblock}{Problème du coût de $\D\x$}
Coût élevé de $\D\x$ : \alert{$O(KN)$} ($K \gg N$)
\end{alertblock}
\end{frame}


\subsection{Motivations}
\begin{frame}{Motivations générales}
\begin{block}{Solution intermédiaire}
Limiter la taille des images ($\rightarrow$ \alert{patches})
\end{block}
\begin{itemize}
\item[\xmark] Mais on ne peut pas représenter de \alert{grandes formes}
\end{itemize}
\begin{exampleblock}{Motivations générales}
Développer un dictionnaire \alert{appris} et \alert{rapide} adaptée aux grands atomes
\end{exampleblock}
\end{frame}







\section{État de l'art}


\subsection{Modèle d'arbre de convolutions}


\begin{frame}{Le modèle d'arbres de convolutions}
\begin{figure}\centering
\makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/tree.pdf}}
\end{figure}
Ainsi, le produit $\D\x$ est réduit à
\begin{equation} 
\D \x = \Beq{\sum_{l \in ~\text{Feuilles}}} \x^{\Beq{l}} * \underbrace{\h^{\Beq{l}}* \dots* \h^{r}}_{\textrm{de la racine à la feuille}}
\end{equation}
soit une complexité en \alert{$O(NQ)$} au lieu de $O(N^2)$ ($Q \ll N$) \\
{\small Q est le nombre total d'éléments des supports $\s^e$}
\end{frame}
 

\begin{frame}{Problème associé}
On appelle \eqref{eq_ftl} (\emph{Fast Transform Learning}) l'adaptation de \eqref{eq_dl} à ce modèle :
\begin{equation*}
\min_{\substack{(\h^e)_{e \in \E} \\ \h^e \in \Dspace^e}}
	\underbrace{\norm{\Beq{\sum_{l \in Feuilles}} \x^{\Beq{l}} * \h^{*\Beq{l}} -\y}{2}^2}_{\text{Fonction objectif } \alert{E(\h)}} \tag{${FTL}$} \label{eq_ftl}
\end{equation*}
avec $\Dspace^e$ la contrainte sur les supports.

L'algorithme \alert{PALMTREE} donne une solution approchée :
\begin{itemize}
	\item \cite{bolte_proximal_2014} : PALM (descente de gradient proximal alterné)
	\item \cite{chabiron_toward_2015} : \eqref{eq_ftl} vérifie les hypothèse de convergence pour PALM
	\item \cite{chabiron_optimization_2016} : le point  critique atteint n'est pas trop éloigné du minimum global
\end{itemize}
\end{frame}

\subsection{L'algorithme PALMTREE}
\begin{frame}{Exemple de solution de PALMTREE}
\textbf{Données en entrée de PALMTREE} \begin{itemize}
	\item image $\y$,
	\item code $\x$ (un code $\x^l \in \R^N$ par feuille)
	\item supports $\s^e$, arbre $\T$
\end{itemize}
\begin{figure}\centering
\makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/1-intro-tree/intro-inputs.pdf}}
\end{figure}
\end{frame}


\begin{frame}{Exemple de solution de PALMTREE}
\textbf{Données en sortie de PALMTREE} 
\begin{itemize}
	\item les noyaux $\h$ (on note $\h = (\h^e)_{e \in \E}$)
\end{itemize}
\begin{figure}\centering
\makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/1-intro-tree/intro-outputs.pdf}}
\end{figure}
\end{frame}


\subsection{Objectifs du stage}
\begin{frame}{Objectifs du stage}
\begin{alertblock}{Inconvénients de PALMTREE}
\begin{itemize}
\item Supports fixes = perte d'adaptabilité
\end{itemize}
\end{alertblock}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1\linewidth]{figures/meilleur-support.pdf}}
\end{figure}
\begin{exampleblock}{Objectifs du stage}
Apprendre les supports à partir de l'image $\y$
\end{exampleblock}
\end{frame}




\section{Travail réalisé}

\subsection{Idée directrice inspirée de l'OMP}
\begin{frame}{L'idée}
\begin{block}{Algorithme OMP (Orthogonal Matching Pursuit)}
	\begin{enumerate}
		\item \textbf{Chercher} élément à ajouter au support $\rightarrow$ \alert{gradient $\nabla E(\H)$}
		\item \textbf{Projeter} pour prendre en compte l'ajout $\rightarrow$ \alert{PALMTREE}
		\item Recommencer
	\end{enumerate}
\end{block}
\begin{exampleblock}{Questionnements}
\begin{itemize}
	\item Gradient adapté pour ajouter le meilleur élément possible ?
	\item Cet algorithme fonctionne t-il dans le cadre d'un arbre ?
\end{itemize}
\end{exampleblock}
\end{frame}


\subsection{Gradient adapté pour ajouter des éléments ?}

\begin{frame}{Explications des expériences sur le gradient}
\alert{Données en entrée} de PALMTREE pour les expériences sur le gradient
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1\linewidth]{figures/2-check-gradient/branche-setup.pdf}}
\end{figure}
\end{frame}

\begin{frame}{Gain versus gradient}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/2-check-gradient/gradient-vs-gain.pdf}}
\end{figure}
\end{frame}

\begin{frame}{Résultats après ajout}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.0\linewidth]{figures/2-check-gradient/apres-ajout.pdf}}
\end{figure}
\end{frame}

\subsection{Ça fonctionne sur un arbre ?}

\begin{frame}{Explication des expériences sur un arbre}
\alert{Données en entrée} pour les expériences sur les arbres
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.0\linewidth]{figures/3-learn-tree-scattered/learn-inputs.pdf}}
\end{figure}
\end{frame}

\begin{frame}{Détail algorithme OMP-PALMTREE}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/3-learn-tree-scattered/algo-omp-palmtree.pdf}}
\end{figure}
\end{frame}

\begin{frame}{Problème des supports dispersés}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/3-learn-tree-scattered/scattered-tree.pdf}}
\end{figure}
\begin{alertblock}{Problème d'identifiabilité des atomes}
Un atome avec 16 morceaux dispersés \alert{ou} 16 atomes bien séparés ?
\end{alertblock}
\end{frame}

\begin{frame}{Ajout d'un à priori sur les supports}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/3-learn-tree-scattered/scattered-explication.pdf}}
\end{figure}
\end{frame}


\begin{frame}{À priori $f$}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=0.8\linewidth]{figures/3-learn-tree-scattered/unscattered.pdf}}
\end{figure}
\end{frame}

\begin{frame}{Réglage de $\alpha$}
\begin{itemize}
\item Nous avons déterminé $\alpha$ au cas par cas
	\begin{figure}\centering
	    \makebox[\linewidth]{\includegraphics[width=0.8\linewidth]{figures/3-learn-tree-scattered/alpha.pdf}}
	\end{figure}
\item Déterminer $\alpha$ pendant OMP-PALMTREE : méthode SURE \cite{eldar_generalized_2009} ?
\end{itemize}
\end{frame}

\begin{frame}{Problème de déséquilibre avec à priori $f$}
\begin{itemize}
\item \alert{Déséquilibre :} 55 éléments au centre, 3 élément sur les feuilles
	\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1\linewidth]{figures/4-learn-tree-unbalanced/unbalanced.pdf}}
	\end{figure}
\item Trop d'éléments au centre $\rightarrow$ convolutions lentes (lié à l'implémentation)
\item Adapter $f(p)$ en fonction de l'arc $e$ ?

\end{itemize}
\end{frame}



\begin{frame}{Modification de la fonction d'à priori $f$ pour équilibrer}
\begin{figure}\centering
    \makebox[\linewidth]{\includegraphics[width=1.1\linewidth]{figures/4-learn-tree-unbalanced/essai.pdf}}
\end{figure}
\end{frame}


\begin{frame}{Conclusions}

\begin{itemize}
\item[\cmark] \textbf{Verrou levé :} bon algorithme PALMTREE mais supports \alert{fixes} \\
	$\rightarrow$ \alert{estimation} des supports avec OMP-PALMTREE

\end{itemize}
Prochainement
\begin{itemize}
\item Estimer $\alpha$ à partir des données
\item Permettre la suppression d'éléments
\item Apprendre l'arbre

\end{itemize}
Pistes lointaines
\begin{itemize}
\item[\textcolor{purple}{\ding{43}}] Apprendre sur plusieurs images
\item[\textcolor{purple}{\ding{43}}] Passer à un algorithme d'apprentissage de dictionnaire complet
\end{itemize}
\vfill
\hfill Merci de votre attention
\end{frame}

\appendix

\begin{frame}[allowframebreaks,noframenumbering]
\frametitle{Bibliographie}
%\nocite{}
\printbibliography[heading=none]
\end{frame}


\end{document}